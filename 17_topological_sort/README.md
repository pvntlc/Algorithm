### 위상정렬(Topological Sort)이란?

- 비순환 방향 그래프의 모든 정점을 선후 관계를 지키며 나열하는 정렬.
- 주로 단독으로 나오진 않고, 정말 가끔 다른 그래프 알고리즘과 함께 나온다.
- 순서가 정해져 있는 작업을 차례로 수행해야 할 때, 작업의 순서를 결정한다.
- 위상 정렬의 결과는 여러 가지가 가능하다.
- 사이클이 없는 방향 그래프에서 사용한다.
- 일상 생활에서는 보통 스케줄을 짤 때 많이 쓰인다.

### 위상 정렬 과정

- 위상 정렬의 결과는 여러 가지가 가능하기 때문에 선후 관계만 맞으면 된다.
- ex) 1-4-3-6-2-5-7, 1-3-4-6-2-5-7 등..

### 위상정렬의 과정과 실제 구현

1. 진입차수가 0인 정점을 찾아서 나열한다.
2. 1에서 찾은 정점과 그 정점으로부터 나오는 간선을 그래프에서 삭제한다.
3. 1-2 과정을 반복한다.
4. 그래프가 모두 사라지면 종료한다.

---

1. 진입차수가 0인 정점을 찾아서 컨테이너에 저장한다.
2. 1에서 찾은 정점과 연결된 정점의 진입차수를 1씩 감소시킨다.
3. 1-2 과정을 반복한다.
4. 모든 정점이 선택되었다면 종료한다.

+++ 만약 사이클이 존재한다면 진입 차수가 0인 정점이 존재하지 않으므로, 위상 정렬을 구현할 수 없다.

### 사실 DFS로도 구현할 수 있다?

- DAG에서 DFS를 실행하면서 한 정점의 탐색이 끝났을 때를 저장하면, 이 순서의 역순이 위상정렬한 결과와 같다.
- DFS가 끝났다는 것은 더 이상 깊게 파고들 정점이 없다는 것을 의미하기 때문이다.
- 스택을 이용하여 DFS가 끝나고 리턴 시 현재 정점을 삽입해준다.

```cpp
void dfs(int node){
	if(visited[node])
		return;
	visited[node] = true;
	for (int i = 0 ; i<graph[node].size(); i++){
		dfs(graph[node][i]);
	}
	finished[node] = true;
	st.push(node);
}
```

### 마무리!

- 일상 속에서 일의 순서를 정해야할 때 사용하는 것이 위상 정렬.
- 그래프의 선후 관계가 주어졌을 때, 모든 정점을 차례로 나열한다.
- 선후 관계가 존재하는 정점들만 지키면 되기 때문에, 여러 가지 결과가 나올 수 있다.
- 사이클이 존재하면 위상 정렬을 할 수 없다.
- 진입차수를 저장한 배열과 진입차수가 0인 정점을 관리할 큐를 사용해서 구현한다.
- DFS 사용해서도 구현 가능하다.
- DFS를 활용한 풀이도 직접 디버깅해보자!