## 정수론

코딩테스트에서 주로 나오는 정수론 문제는 다음과 같다.

- 약수 배수
- 최대공약수 최소공배수
- 소수 판별

### 최대공약수

- 소인수분해를 이용하여 구하기 > 각 수의 소인수를 모두 구해야하므로 생각보다 구현이 까다로움.
- 두 수 중 작은 수 기준으로 돌리면서 가장 큰 공통 약수 구하기 > 시간복잡도 O(n)이므로 비효율적.
- **유클리드 호제법 > 시간복잡도가 O(log(n))이며, 구현도 어렵지 않음.**

### 유클리드 호제법

예를 들어 A와 B의 최대공약수를 구하려고 한다면, A-B와 B의 최대 공약수를 구한다고 할 수 있다.

1. A = a * G
2. B = b * G (단, a와 b는 서로소여야 함)
3. A-B = (a-b) * G → a-b와 b또한 서로소 이므로, A-B와 B의 최대공약수도 G이다.

라는 원리를 이용해서 최대 공약수를 구하는 것인데, A와 B의 차이가 크면 오래 걸린다.

이 때문에, A와 B의 최대 공약수는 **A%B와 B의 최대공약수를 구하는 것**과 똑같다는 것을 이용한다.

1. A = a * G
2. B = b * G (단, a와 b는 서로소여야 함)
3. A = q * B + r (q는 A/B의 몫,  r = A%B)이므로,
4. 1,3번 식을 이용해 다음과 같이 둘 수 있다.
    1. r  = a * G - q * B
    2. B에 2번식을 대입하면, **r = a * G - q * b * G = (a - q * b) * G**이다.
5. a - q * b와 b 또한 서로소 이기 때문에, A % B와 B의 최대공약수도 G이다.

예를 들어, 28과 8의 최대 공약수를 구한다고 한다면, 28%8과 8의 최대공약수를 구하는 것과 다름 없다.

1. 28 = 7 * 4
2. 8 = 2 * 4
3. 28 = 3 * 8 + 4
4. 4 = ( 7 - 3 * 2 ) * 4.

→ 1과 2 또한 서로소 이기 때문에 28 % 8과 8의 최대공약수도 4이다.

GCD(28,8) = GCD(4,8).

### 구현 로직

```python
def gcdIter(a,b): # 최대공약수
	while(b):
		a,b = b,a%b
	return a

def lcmIter(a,b): # 최소공배수
	return a * b / gcdIter(a,b)
```

### 소수 판별

- 2 ~ n까지 돌리면서 나눠지는 수가 없는지 판단 → O(n)
- 2 ~ root(n)까지 돌리면서 나눠지는 수가 없는지 판단 → O(root(n))
- n이 큰 상황에서 2 ~ n 사이에 존재하는 모든 소수를 구해야 한다면?
    - 에라토스테네스의 체 사용

### 에라토스테네스의 체

- 각 수가 소수인지 판단한 여부를 저장하는 배열 사용.
- 2부터 시작해서 해당 숫자의 배수에 해당하는 숫자들을 지워나간다.
    - 약수가 존재하면 소수가 아니기 때문.
- O(nlog(logn))만에 2~n까지 수에 대해 소수 판정이 가능하다.


- 기본 로직
```python
#에라토스테네스의 체!
def isPrime(n):
    prime_list = [True] * (n+1)
    prime_list[0] = prime_list[1] = False

    for i in range(int(n**0.5)+1):
        if prime_list[i]:
            for j in range(i**2,n+1,i):
                prime_list[j] = False
    return prime_list
```