## 투 포인터(Two Pointers)

- 두 개의 포인터를 이용해서 배열을 빠르게 탐색하는 알고리즘.
- 코딩 테스트에서는 주로 효율성을 보는 문제에 활용된다.

| 7 | 2 | 162 | 1 | 38 | -3 |
| --- | --- | --- | --- | --- | --- |
- 다음과 같은 배열 A가 있을 때, A[i]부터 A[j]까지의 합은?
    
    → 더할 때마다 시간 복잡도가 O(n)이며, 만약 배열의 크기가 10000일 때, 구하고자 하는 구간이 1,000,000개만 돼도 총 연산 횟수가 100억이다….
    
- 연산 횟수를 줄일 수 있는 방법은 없을까?
    
    → 누적 합을 이용해서 줄일 수 있다. 누적 합 배열을 S라 하면, S[0] = 7이고, S[1] = S[0] + 2, S[2] = S[1] + 162와 같은 방식으로 연산 횟수를 줄일 수 있다.
    

### 11659번 : 구간 합 구하기 4 - Silver 3

- 수 N개가 주어질 때, i번째 수부터 j번째 수까지의 합은?
- N,M은 1이상 100,000이하.

→ 순차 탐색으로 구현하게 되면 최대 연산 횟수가 100,000^2으로 시간 초과이다.

```python
# 11659번 : 구간 합 구하기 - Silver 3
import sys
input = sys.stdin.readline
INF = sys.maxsize

"""
"""

n, m = map(int, input().split())
n_list = list(map(int, input().split()))
sum_list = [0]

for i in range(n):
    sum_list.append(sum_list[-1] + n_list[i])

for i in range(m):
    s, e = map(int, input().split())
    print(sum_list[e] - sum_list[s-1])
```

### 슬라이딩 윈도우

- 누적합을 사용하지 않고 문제를 풀이하는 방법.
- 고정 사이즈의 윈도우가 이동하면서 윈도우 내에 있는 데이터를 이용해 문제를 풀이하는 알고리즘.
- 교집합의 정보를 공유하고, 차이가 나는 양쪽 끝 원소만 갱신하는 방법.
- 배열이나 리스트의 요소의 일정 범위의 값을 비교할 때 사용하면 매우 유용하다.

```
슬라이딩 윈도우 예제

 1,2,3,4,5로 이루어진 배열에서 연속적인 3개의 숫자의 합을 최댓값을 구한다고 가정하면
다음과 같은 3가지의 경우의 수가 나온다.

[1,2,3],4,5
1,[2,3,4],5
1,2,[3,4,5]

 이 경우에 슬라이딩 윈도우를 사용해서 합의 최댓값을 구하는 과정은 다음과 같다.

1. 먼저 처음 배열 [1,2,3]의 합을 구한다.
2. 다음 배열은 [2,3,4] 이기 때문에 맨 앞 값인 1이 빠지고 그 다음 값인 4가 들어간다.
3. 이러한 규칙으로 진행하다보면 다음 배열의 값은 전 배열에서 처음 원소를 빼고 다음에
들어올 원소를 더해주면 된다.
```

### 21921번 : 블로그 - Silver 3

- N일간의 방문자 수가 주어진다.
- 연속된 X일 동안 가장 많이 들어온 방문자 수와 그 기간의 수는 몇 개인가?
- 최대 방문자 수가 0명이라면 SAD를 출력한다.
- N과 X는 1이상이며 250,000 이하이다.
- 방문자 수 k는 0이상 8,000이하이다.

```python
# 21921번 : 블로그 - Silver 3
import sys
input = sys.stdin.readline
INF = sys.maxsize

"""
5 2
1 4 2 5 1
"""

n, x = map(int, input().split())
n_list = list(map(int, input().split()))
start, end = 0, x-1
temp = sum(n_list[start:end+1])
max_value = temp
count = 1

while end != n-1:
    temp = temp - n_list[start] + n_list[end+1]
    if max_value == temp:
        count += 1
    elif temp > max_value:
        max_value = temp
        count = 1
    start += 1
    end += 1

if max_value == 0:
    print("SAD")
else:
    print(max_value, count, sep="\n")
```

### 정리!

- 2개의 포인터로 배열을 탐색하며 빠르게 답을 찾는 알고리즘.
- 주로 반복문으로 구현한다.
- 일반적으로 시간 복잡도 O(n^2)의 문제를 O(n)으로 풀 수 있다.
- 탐색 방법은 크게 두 가지로, 다른 위치에서 시작하여 서로에게 다가가는 방향 아니면 같은 위치에서 시작해서 같은 방향으로 탐색하는 것이다.
- 서로에게 다가가는 방향으로 탐색하는 것은 일반적으로 정렬되어 있을 때가 많다.
- 슬라이딩 윈도우는 같은 위치에서 시작해서 같은 방향으로 탐색하는 방식이다.